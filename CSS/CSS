웹페이지 안에 CSS를 삽입하는 방법
1. style 태그를 쓴다. 
2. style 속성을 쓴다.

  <style>
    a {
      color:black;
      text-decoration : none; // 밑줄이 없어진다.
    }
  </style>

</head>
<body>
  <h1><a href="index.html">WEB</a></h1>
  <ol>
    <li><a href="1.html">HTML</a></li>
    <li><a href="2.html" style="color:red"(CSS속성을 쓴다는 뜻.)>CSS</a></li>
    <li><a href="3.html">JavaScript</a></li>
  </ol>
  
  
  <style>
    a {
      color:black;
      text-decoration : none; // 밑줄이 없어진다.
    }
  </style>
  
  a{} = 선택자 selector (태그 a가 들어가있는 곳을 지정)
  color:black = 효과 declaration
  color = 속성 property
  black = 값 value
  
  
  
  <style>
    #active {
      color:red;
    }
    .saw {
      color:gray;
    }
    a {
      color:black;
      text-decoration: none;
    }
    
  </style>
  
  <li><a href="1.html" class="saw">HTML</a></li>
    <li><a href="2.html" class="saw" id="active">CSS</a></li>
    <li><a href="3.html">JavaScript</a></li>
  
  saw{}: 태그 saw가 들어가 있는 곳을 지정
  .saw{} : saw라는 class를 지정
   #saw{} : id가 들어가있는 곳을 지정
  
 CSS는 뒤에 쓴것이 오버라이딩 됨.
 그래서 우선순위를 위해 id 선택자를 씀
 id > class > tag 선택자
 
 id 선택자는 단 한번만 쓰게 되어있다.
 id값은 중복 X. 유일무이
 
 
 
 박스모델 
 
 block level element : 화면 전체를 씀 ex)h1
 inline element : 자기 자신의 크기만큼 씀 ex)a

block level element 에서 display:inline 하면 inline element가 됨.
반대도 가능
display : none 하면 화면에서 사라짐. 

h1 ,a{
    border-width :5px;
    border-color:red;
    border-style : solid;
  }
 
-> 
h1 ,a{
    border : 5px solid red;
  }



  h1 ,a{
      border : 5px solid red;
      padding : 20px;
      margin : 0;
      display:block
    }
    
    padding : border와 글자 사이
    margin : border와 border 사이
    폭 width 높이 height
    
    
    block 단위일때 inline을 안쓰고 width로 조절 할수 있다.
    
    
    grid
    <h1>태그 같은경우 제목이라는 뜻을 가지고 있어서 그냥 사용하기는 어색하다.
    그럴때 쓰는 것이 div인데 div는 무색무취와 같은 아무 의미없는 태그이다.
    
    div 는 block level element
    span은 inline element
    

#grid{
    border:5px solid pink;
    display:grid;
    grid-template-columns: 2fr 1fr; 
  }
  
 2fr,1fr은 화면 크기가 3fr이라고 했을때 2:1로 나눈다.


ul li
ul 밑의 li
ul>li
ul 바로 밑의 li

flukeout.github.io
들어가서 선택자 연습해보기
특정 태그안의 class 지정
태그.class

* 
전체

plate * 
plate 밑에있는 모든 태그

A+B
태그 A 인접한 바로 뒤의 B

A~B
A의 인접한 바로뒤의 태그부터 B까지 전부

plate orange: first-child

plate태그 안에있는 orange 태그 중 첫번째 태그

A,B 
둘 다 선택하는 선택자

plate *:only-child
plate 밑의 포함된 태그가 하나일 경우만 해당된다.

.small:last-child
small이라는 class안에 마지막인 태그만 뽑아낸다.

plate:nth-child(3)
 전체에서 3번째이면서 plate태그를 뽑아낸다.

bento:nth-last-child(3)
뒤에서 3번째이고 벤또인것을 뽑아낸다.

apple:first-of-type
apple 태그가 처음 등장하는 것을 선택한다.

plate:nth-of-type(even)
태그가 짝수로 있는 것만 뽑아낸다.

plate:nth-of-type(2n+3)
컴퓨터가 0,1,2,3,... 계속 넣어본다.
(수열) 그 값을 뽑아낸다.

apple:only-of-type
자기 자신과 같은 타입의 sibling이 존재하지 않는 것. (자기 자신만 존재할때)
타입이 다른건 ok!

apple:last-of-type
apple의 마지막 타입을 뽑아낸다.

bento:empty
bento 중에서 아무것도 갖고있지 않은 태그.

apple:not(.small)
apple 태그중 .small 클래스가 아닌 태그.




a:active 
anchor를 마우스로 누르고 있을때
a:hover 
anchor 위에 있을때
a:visited
방문 했던곳(보안 때문에 쓸수있는 속성이 제한되어 있다.)
a:link
방문 안했던 곳
a:focus
tab키를 누르면 focus된다. (마지막에 써주는게 좋다. (input창일때 색깔바뀌게 가능)


font-size 제일 많이 사용됨.
px vs em vs rem
rem이 최근에 추가된 단위.
px은 크기가 고정되어있다.
em,rem은 브라우저의 설정에 따라서 폰트의 크기가 달라진다.
오늘날에는 rem이라는 것만 쓰면 된다.

줌인, 줌아웃 말고
설정화면에서 폰트 크기를 설정할 수 있는데, rem은 바뀌고 px는 바뀌지 않는다.

폰트사이즈를 바꾼다는 것은 html의  폰트사이즈를 바꾼다는 것이고, 우리가 rem단위를 사용하면 html태그의 폰트 크기에 비례하게 된다. 
css가 2rem이면 
html의 폰트사이즈 * 2

color 속성
1. color-name(blue)
2. hex (#FFFFFF)
3. rgb (255,255,255)

text-align:justify;
를 하게되면 왼쪽과 오른쪽이 공평하게 화면을 차지하게 된다. 텍스트와 텍스트 사이의 간격이 달라지기 때문(역효과가 일어날 수도 있다.)

font-family:arial, verdana, "Helvetica Neue" ,serif;
arial 폰트체가 없으면 verdana. verdana도 없으면 Helvetica Neue.

Sans-serif : 글자에 장식이 없는 것
Serif : 글자에 장식이 있는 것
monospace : 고정폭. 우리가 데이터를 볼때(고딩할때)
위의 3개중 하나는 써줘야 한다.

font-weight : bold;
글짜 두께
line-height: 2;(2배)
자간 (라인의 간격)


font
폰트와 관련된 여러 속성을 축약형으로 표현하는 속성입니다. 형식은 아래와 같습니다. 순서를 지켜서 기술하셔야 합니다. 

font: font-style font-variant font-weight font-size/line-height font-family|caption|icon|menu|message-box|small-caption|status-bar|initial|inherit; 
 
 webfont는 사용자가 해당 사용자가 없을때 서버에서 다운로드해서 사용자가 사용할 수 있게 해준다.
한국어는 폰트는 용량이 크다. 

https://fonts.google.com/ 여기가면 폰트가 공짜이다.

검사후에 network탭에 들어가면 구글에서 font를 받는다는 것을 알 수 있다.

웹폰트를 만드는 법.
인터넷에 없는 폰트가 내 컴퓨터에만 있으면 font generator을 검색해서 폰트를 업로드 하고 다운받아서 쓰면 된다.

    li{color:red;}
    h1{color:red;}
    html{
        color:red;
    }

    html은 제일 조상이다.(object)
    li, h1 은 자식들 
    즉 자식들을 계속 쓰는 것보다.
    조상을 한번 써주고 필요한 부분만 자식들이 변경해주는게 더 효율적이다. 이것을 상속이라 한다.
    상속 덕분에 효율적으로 이용할 수 있다.
    그러나 css마다 상속되고 안되고의 차이가 있다.
    폰트의 컬러는 상속이 된다. 테두리는 상속이 되지 않는다.


    CSS: Cascading Style Sheet
웹브라우저, 사용자, 저자(컨텐츠 생산자)
우선순위 : 웹브라우저 < 사용자 < 저자
사실 사용자가 우선순위가 제일 높아야 한다고 생각한다.
cascading 우선순위 규칙:

<style>
        li{color:red;}
        #idsel{color:blue;}
        .classsel{color:green;}
    </style>
</head>
<body>
    <ul>
        <li>html</li>
        <li id="idsel" class="classsel" style="color:powderblue">css</li>
        <li>javascript</li>
    </ul>

    tag selector <class selector < id selector < style attribute

그러나 
li{color:red !important;}
!important를 써주면 우선순위가 제일 높아진다. 하지만 좋은 방법은 아니다.


inline vs block level element
자기 글자만 표현하는 것이 inline
전체를 이용하는 것이 block
그러나 inline에서 block으로 그 반대로도 가능하다.

h1{display : inline;} //h1은 원래 block이지만 inline으로 바꿔준다.
a{display:block;}


 border:10px solid red;
 을써서 박스의 사이즈를 보면서 개발하는 것이 좋다


 padding : 텍스트와 테두리 사이의 간격.
 margin : 테두리와 다른요소들 사이의 간격.
 p태그는 블록단위라 width,height값에 영향을 받지만
 a는 inline단위 이므로 width,height 값에 영향을 받지 않는다. 

 div{
        margin:10px;
        width:150px;
    }
    #small{
        border:10px solid black;
    }
    #large{
        border:30px solid black;
    }

하면 두개의 사이즈가 달라보인다.
그 이유는 css의 초창기에는 padding과 border가 없이 width값으로만 지정했기 때문에
content영역 크기만 같다. 하지만 border값이 생기면서 까다로워 졌다. 그래서 box-sizing이 나왔다.

box-sizing:border-box;
하는 순간 두개의 크기가 border값을 포함해서 같게된다. 그래서 보통*{}을 사용해서 모든 element가 border의 크기를 width와 height값으로 사용할 수 있게 해서 코딩을 수월하게 해준다.

마진겹침 : 두개의 마진 중에 더 큰값이 두개의 태그사이의 간격이된다.

마진겹침 2 :부모 element아래에 자식 element가 있고 부모와 자식 모두 margin값이 있을때 생기는 경우 
즉 부모태그가 시각적으로 아무런 효과가 없는 상태가 되면, 자식태그와 부모태그의 마진값이 합쳐지는 결과를 낳는다.
부모 엘리멘트의 마진값과 자식 엘리멘트의 마진값의 큰쪽의 마진값이 자식 엘리먼트의 마진값으로 사용된다. 즉 부모가 투명하고 부모와 자식의 마진값중 큰것을 마진값으로 이용한다.

시각적인 요소: border건 글자건 눈에 보이면 시각적인 요소가 있는 것이다.

마진겹침3: 만약 태그에 시각적인 요소가 없다면
그 태그의 마진값은 위쪽에 있는 마진값과 아래쪽에 있는 마진값중에 더 큰 값이 그 태그의 마진 값이 된다. 
margin-top이 80이면 margin-bottom이 

tip: 
#parent>#child + tab키를 누르면
=>
<div id="parent">
        <div id="child"></div>
    </div>

  
POSITION
position은 html의 태그들 element들이 화면상 어디에 위치해 있을 것인가? box model이 부피감 또 element와 element의 간격을 지정하는 것이었다면 포지션은 각각의 엘리먼트의 위치를 지정하는 정말 중요한 것.

position_1.html 참고
CSS의 element들은 포지션의 기본값을 가지고 있다. 그 값은 static이다. static이라고 지정하면 left,top,bottom,right 등 offset값을 무시하고 static하게 위치해 있는다. 자기가 있어야 할 위치를 (부모 element의 아래)기준으로 해서 상대적으로 100px만큼 왼쪽으로 가고싶다 하면 relative로 지정하면 된다.

absolute
html element를 기준으로 위치를 조정하고 싶을때
relative는 부모 element를 기준으로
그러나 absolute여도 left, top을 지우면 부모 element기준으로 한다.
그러나 부모나 그 위의 부모의 position을 static이 아닌 값을 주면(default값은 static) 그 부모element를 기준으로 offset이나 top의 값을 적용한다.

fixed
absolute값과 같은 것처럼 보인다.
하지만 스크롤로부터 완전히 독립되어서 스크롤을 내려도 항상 그자리에 있다.
(네비게이션 바 처럼) absolute처럼 width와 height가 없애면 부모가 없어지기 때문에 자신의 content 크기가 된다.


FLEX
Layout을 잡을 때 쓴다.
Layout의 흑역사.

TABLE이 있었다.(Grid 모양)
처음에는 table로 layout을 만들어 썼다. 그러나 table이 표로 사용된것인지 layerout으로 사용된 것인지를 구분하기 힘들어졌다. 그리고 table의 용량이 크기때문에 나중에 변경하기가 힘들어졌다.
그래서 table로 layout을 쓰지말자는 운동이 일어났다.
position을 통해서 위치를 변경했다.
float도 layout을 잡는데 사용했다. 하지만 layout을 사용하기위해 만든것은 아니다.
인류는 갈팡질팡~ 그러다 궁극의 layout이 나옴 : FLEX

flex를 사용하기 위해서는 tag가 2단계가 필요하다. 마치 li태그가 ol이나 ul태그가 필요하듯이. 
container의 역할을 하는 태그와 그 안의 item의 역할을 하는 태그

container에게 부여해야 할 속성
display
flex-direction
flex-wrap
flex-flow
justify-content
align-items
align-content

item에게 부여해야 할 속성
order
flex-grow
flex-shrink
flex-basis
flex
align-self


tip: .class>.item{$}*5
 class라는 div안에 class 값이 item을 5개 만드는데 1씩증가해서 만듬

 div는 block level element
 부모 div에 flex를 주면 자식 div는 달라진다. (div는 block level인데 inline으로 됨)

  flex-direction:row-reverse; 속성을 주면 반대쪽으로 간다. 
  flex-direction:column; 으로 하면 세로로 정렬이 된다.

  height 값이 들어가고 column-reverse를 하면 flex가 있고 없고의 차이가 나타난다. container 바닥으로 부터 올라간다.(없으면 맨 위에서 위치만 바뀜)
  또한 block단위도 아니고, inline 단위도 아닌 container단위로 바뀐다.(row로 하면 아래로 쭉, column으로 하면 옆으로 쭉 차지한다.)

  ||||||| row
  ------- column

  flex-basis :200px;
  플렉스 방향에 따른 크기의 속성(row일 경우 옆으로 퍼지고 column일 경우 아래로 커짐)

  flex-grow : 1
  각각의 아이템에게 grow를 시켜준다. (1/n로 나눠갖는다.)

  더 키우고 싶은 아이템에게 flex-grow:2를 주면 5개가 있을때, 다른애들은 1/6을 가져가는데 혼자 2/6만큼 가져가서 커진다.

cascading : 우선순위
flex는 반응형이다! 화면이 작아졌을때 여유가 있는 아이템은 크기가 줄어든다.
이때 이기적이게 여유가 있어도 줄어들지 않게하는 속성이 있는데 
flex-shrink:0;
이다. flex-shrink:1을 주면 고통분담을 한다.
flex-shrink:2를 한다면 2/3만큼 고통을 분담해서 더 빨리 줄어든다.
즉 flex-basis값이 있을때 줄이는 용도로 shrink을 쓴다 (세트메뉴)


Holy Grail Layout :성배 layout

      Hader
Nav   main    AD
      Footer

이런 layout을 만들기 위해 많은 사람들이 노력했다. 최적화.
but, flex layout의 등장으로 손쉽게 할수 있다!.

Holy Grail Layout 
https://www.youtube.com/watch?v=8DJBCHro-3Q&list=PLuHgQVnccGMDaVaBmkX0qfB45R_bYrV62&index=37



