라우터는 애플리케이션의 뷰 상태에 반응하는 객체로 이해해도 된다. 개발자는 Angular 프레임워크가 제공하는 라우터를 원하는 대로 설정하기만 하면 된다.

```
딥 링킹(Deep linking)

어떤 웹페이지를 가리키는 링크를 만드는 것에서 좀 더 나아가, 웹 페이지의 특정 내용으로 접근하는 링크를 만드는 것을 딥 링킹이라고 한다. 이전 절에서 살펴본 라우터 예제에서도 딥 링킹을 사용하는 것을 확인 할 수 있는데,
http://localhost:8080/#/product/1234 라는 URL은 상품 정보 페이지를 가리키는 것 뿐만 아니라, 이 페이지에서 ID가 1234인 상품의 상세 정보를 표시한다는 것을 뜻한다.

http://localhost:8080/#/product/1234/seller/5678 라는 URL은 한 단계 더 들어간다.
이 URL은 ID가 1234인 상품을 판매하는 판매자 중 ID가 5678인 판매자에 대한 정보를 표시하는 페이지를 뜻한다.
```

# Angular가 지원하는 Shadow DOM
Shadow DOM은 전역 DOM과 분리된 별개의 DOM 계층을 구성한다. 그리고 이 Shadow DOM은 HTML 문서에 포함되어 렌더링되지만, HTML 문서에 해당하는 전역 DOM에서 Shadow DOM 내부의 엘리멘트에 접근할 수 없다.

커스텀 태그를 만들 때, Shadow DOM은 이 HTML 조각을 웹페이지 DOM에 추가하지 않고 별개의 컴포넌트로 관리한다. 이렇게 컴포넌트를 분리하면 **컴포넌트 안에 적용하는 CSS 스타일이 전역 DOM CSS**에 영향을 주지 않으므로, 스타일이 잘못 지정되는 문제를 방지할 수 있고 전역 DOM에서 발생하는 영향을 사전에 차단할 수 있다.

## ViewEncapsulation.Emulated 
Angular 프레임워크가 제공하는 방식으로 shadowDOM을 캡슐화한다(기본값). 이 방식에서는 HTML 엘리먼트에 어트리뷰트를 추가해서 이 컴포넌트의 스타일이 전역 DOM의 스타일에 영향을 주지 않도록 한다. Chrome 개발 도구에서 SellerInfoComponent를 보면, 이 컴포넌트의 HTML 마크업은 이렇게 생겼을 것이다.

```html
<head>
...
<style>[_nghost-c2] {background : yellow} </style>
...
</head>
<body>
...
<seller _nghost-c2-""> The seller of this </seller>
</body>
```

## ViewEncapsulation.Native
브라우저에서 지원하는 Shadow DOM을 사용한다. 이 경우에도 컴포넌트의 HTML과 스타일은 웹 페이지의 DOM과 별개로 존재한다. 이 옵션은 브라우저에서 Shadow DOM을 지원하는 것이 확실할 때만 사용해야 하며, 지원하는 않는 경우에는 에러가 발생
SellerInfoComponent의 스타일은 \<head>로 합쳐지지 않고 컴포넌트 안에 캡슐화된 영역에 위치한다.

## ViewEncapsulation.None
Shadow DOM 캡슐화를 사용하지 않으며, 컴포넌트의 모든 HTML과 스타일을 전역 웹페이지 DOM에 포함시킨다. 이 경우에는 Shadow Host가 없기 때문에 :host 셀렉터도 동작하지 않는다. 이때 :host 셀렉터 대신 컴포넌트 자신의 셀렉터를 사용할 수 있다.

# 라우팅 가드
이제 사용자가 라우터를 통해 들어오거나 나갈 때 유효성을 검증하고 검증 결과를 라우터에 반영하는 방법을 알아보자, 이 동작은 다음과 같은 경우에 활용할 수 있다.

1 . 사용자가 인증을 한 후에만 라우팅을 수행하고, 인증을 하지 않았다면 인증을 하게 된다.

2 . 컴포넌트 몇 개로 만든 폼을 화면에 표시하고, 이 폼에 유효한 데이터를 입력한 경우에만 내비게이션을 허용한다.

3 . 라우터에서 빠져나갈 때 저장하지 않은 정보가 있는 것을 사용자에게 알린다.

path, component data프로퍼티만 사용했지만, 라우팅을 막을 때 사용되는 canActivate와 canDeactivate 프로퍼티에 대해 알아보자. 

canActivate() 함수를 구현하는데, 이 함수는 유효성을 검증해서 true나 false 값을 반환하도록 구현한다. 그리고 이 클래스를 라우터 설정의 canActivate 프로퍼티에 연결하면 라우터 가드 클래스의 canActivate() 함수가 true를 반환할 때만 라우터가 제대로 동작한다. 
canDeactivate는 true를 반환할 때만 라우터의 내비게이션에서 벗어날 수 있다.


ActivatedRouteSnapshot과 RouterStateSnapShot 인스턴스는 Angular에 의해 자동으로 주입되며, 현재 라우터의 상태를 참고할 때 간편하게 사용할 수 있다. 예를 들어, **사용자가 라우터를 통해 이동하려는 컴포넌트의 이름을 알고 싶다면** 다음과 같이 사용한다.
```js
canActivate(destination : ActivatedRouteSnapshot, state:RouterStateSnapshot)
{
    console.log(destination.component.name);
}
```

CanDeactivate 인터페이스를 구현하는 과정도 CanActivate와 비슷하며, canDeactivate() 함수를 구현한 가드 클래스를 만들면 된다. 다음 코드는 라우터를 벗어날 때 저장되지 않은 내용을 폐기할 것인지 묻는 가드이며, app/guards 폴더에 unsaved_changes.guard.ts파일로 만든다.

```js
import { CanDeactivate } from '@angular/router';
import { Injectable } from '@angular/core';

@Injectable()
export class UnsavedChangesGuard implements CanDeactivate {
    canDeactivate () {
        return window.confirm('You have unsaved changes. leave?');
    }
}
```

```html
<router-outlet></router-outlet>
<router-outlet name="name"></router-outlet>
```
