라우터는 애플리케이션의 뷰 상태에 반응하는 객체로 이해해도 된다. 개발자는 Angular 프레임워크가 제공하는 라우터를 원하는 대로 설정하기만 하면 된다.

이제 라우터의 기능을 살펴보고, 온라인 경매 애플리케이션의 두 번째 화면으로 상품 정보 뷰를 추가하자. 사용자가 첫 페이지에서 어떤 상품을 클릭하면 페이지의 내용을 바꾸고, 제품의 상세 정보를 표시할 것이다.

# 라우터
SPA는 첫 페이지 상태, 상품 정보 상태, 배송 조회 상태와 같이 특정 뷰가 표시되고 있는 상태를 모아둔 것이라고 볼 수도 있는데, 한 페이지에 머물러 있으면서 각각의 상태에 맞는 뷰를 표시하는 방식이다. 이런 의미로 보면 온라인 경매 애플리케이션은 **첫 페이지를 표시하는 상태 하나만 있다.**

라우터 영역에는 각 뷰마다 화면에 표시할 컴포넌트를 하나씩 지정한다. 2장에서는 부모 컴포넌트와 캐러셀 컴포넌트, 상품정보 컴포넌트의 관계를 신경 쓰지 않고 만들었지만, 이 장에서는 캐러셀 컴포넌트와 상품 정보 컴포넌트를 HomeComponent에 포함되도록 코드를 리팩토링한다.
그리고 상품의 상세 정보를 표시하는 ProductDetailComponent를 만든다.

SPA가 아닌 웹사이트에서는 주소가 바뀔 때마다 새로운 페이지 요청을 서버로 보내고 요청의 결과로 HTML 문서를 받으면 브라우저에서 전체페이지를 다시 렌더링하는 방식을 사용한다.
비효율!

SPA에서는 화면에 **렌더링될 컴포넌트 코드가 이미 클라이언트에 있기 때문에**(지연 로딩은 제외), 화면에 표시되고 있는 뷰를 **다른 뷰로 바꾸기만 하면 된다.**

사용자가 내비게이션을 사용하면서 데이터 통신을 하기 위해 서버로 요청을 보낼 수도 있다.
데이터를 화면에 표시하는 뷰에서는 필요한 정보를 미리 브라우저에 전부 내려받아 놓고 사용할 수도 있지만, **일반적으로 뷰를 미리 표시하고 AJAX 요청이나 WebSocket을 통해 필요한 정보를 서버에서 가져온다.**
각 뷰는 브라우저의 주소 표시줄에서 구별할 수 있게 유일한 URL을 갖고 있으며, 이 부분에 대해서는 이후에 자세히 살펴본다.

## 위치 정책
브라우저의 주소 표시줄은 언제나 현재 뷰의 URL을 표시한다. URL은 여러 구성요소로 나누어 볼 수 있는데, 프로토콜로 시작해서 도메인 이름이 있고, 그 뒤에 포트 번호가 붙기도 한다.
SPA는 **서버에 요청을 보내지 않고도 URL을 변경할 수 있기 때문에**, 애프리케이션에서는 이 주소를 기준으로 클라이언트의 상황에 맞는 뷰를 표시할 수 있다.

Angular에서 주소를 관리하는 위치 정책은 다음과 같은 방식이 있다.
### HashLocationStrategy(해시기반 내비게이션 정책) 
URL에 해시기호를 사용해서 해시 기호 이후의 부분은 웹 페이지의 특정 부분을 가리키도록 라우팅 하는 정책이다.
### PathLocationStrategy(방문 기록 API 기반 내비게이션 정책)
브라우저의 방문 기록 API를 사용하는 정책이며 HTML5를 지원하는 브라우저에서만 동작한다. 이 정책이 Angular 라우터의 기본 정책이다.

## 해시 기반의 내비게이션
해시 기호 오른쪽의 문자를 바꾼다고 해도 서버로 요청이 가지 않으며, 그 경로에 해당하는 뷰를 표시한다. 해시 기호는 기본이 되는 URL 부분과 클라이언트에서 요구하는 콘텐츠 위치에 대한 경로를 분리하는 용도로 사용한다.

# URL 구성
http://mysite.com:8080/#/product/page/3
프로토콜/도메인이름/포트/   라우팅경로 /라우팅 인자
    서버 위치                 클라이언트 위치

SPA 중 하나인 Gmail을 보면서, 내비게이션을 할 때 URL이 어떻게 바뀌는지 확인해보자.
### 받은 편지함
주소가 https://mail.google.com/mail/u/0/#inbox로 표시된다.
### 보낸 편지함
이동하면 URL 해시 기호의 뒷부분이 inbox에서 sent로 바뀌고, 보낸 편지함의 뷰를 보여주기 위해 필요한 동작을 실행한다.

Angular의 기본 라우팅 정책은 브라우저의 방문 기록 API를 사용하는 정책이지만, 이 책에서는 URL이 **바뀌는 것을 간단하게 확인하기 위해 해시 기반의 내비게이션을 기본값으로 사용하고**, @NgModule 설정에서도 providers 값에 같은 정책을 사용한다.

## 방문기록 API 기반의 내비게이션
브라우저의 방문 기록 API를 사용하면 코드에 의해 **방문 기록 스택을 조작**해서 이전 위치로 이동하거나 새로운 위치로 이동할 수 있다.

API중 pushState() 함수를 사용하면 기본 URL 뒤에 SPA에서 사용하는 내비게이션 정보를 추가할 수 있다.

방문 기록 API 기반의 내비게이션 정책에서는 URL이 http://mysite.com:8080/products/page/3일때 product/page3 부분이 기본 URL인 ~~~에 추가된 정보라고 볼 수 있다. 
사용자가 3페이지에서 4페이지로 이동하면 애플리케이션은 이전 페이지인 product/page/3 **상태를 브라우저 방문기록에 저장**하고 product/page/4에 해당하는 뷰를 렌더링한다.

Angular를 사용하면 pushState() 함수를 따로 호출할 필요 없이 URL과 컴포넌트를 매핑하기만 하면된다.
방문 기록 API 기반의 정책에서는 기본 URL로 어떤 위치를 사용할지 **Angular애플리케이션에서 지정**해야 하며, 이 과정을 거쳐야 기본 URL의 **뒷부분에 클라이언트에서 필요한 추가정보를 제대로 붙일 수 있다.**

# 방문 기록 API 기반의 내비게이션을 사용하기 위한 설정
1 . index.html 파일의 헤더에 \<base href="/">과 같은 형식으로 \<base>태그를 추가한다.
2 . Angular 루트 모듈의 providers 프로퍼티 값을 APP_BASE_HREF로 지정한다. 아래 코드는 기본 URL로 /를 사용하고 있지만, 이 값을 자유롭게 지정할 수 있다.
```js
import { APP_BASE_HREF } from '@angular/common';
...
@NgModule({
    ...
    providers : [{provide : APP_BASE_HREF, userValue:'/'}]
})
class AppModule {}
```

# 라우터 구성 요소
## Router 
라우터를 구현하는 객체다. 원하는 경로로 이동하려면 이 객체의 navigate() 함수의 navigateByUrl() 함수를 사용하거나, 라우터 객체의 path 프로퍼티 값을 변경하면 된다. 브라우저의 URL을 직접수정해도 원하는 경로로 이동할 수 있다.
## RouterOutlet 
라우터가 컴포넌트를 렌더링하는 영역인 \<router-outlet>을 구현하는 디렉티브다.
## Routes
특정 URL에 연결되는 컴포넌트를 지정하는 배열이다.
## RouterLink
HTML 앵커 태그(\<a>)의 원래 용도는 브라우저의 URL 주소를 변경하는 것이지만, RouterLink 디렉티브를 사용하면 **앵커 태그가 Angular 라우터를 통하도록 기능을 변경**할 수 있다.
RouterLink를 사용하면 라우터가 **렌더링할 컴포넌트에 인자를 전달**할 수도 있다.
## ActivatedRoute
현재 동작하는 **라우터 인스턴스**를 가리키는 객체다.

라우터는 Routes 객체를 사용해서 아래 코드와 같이 배열로 설정한다
```js
const routes : Routes = [
    { path : '', component : HomeComponent},
    { path : 'product', component : ProductDetailComponent}
];

```
# 일반적인 내비게이션 순서
1 . URL과 그 주소에 연결되는 컴포넌트를 배열로 매핑하고, 이 배열을 RouterModule.forRoot()**(루트모듈)** 함수나 RouterModule.forChild()**(기능모듈)** 함수의 인자로 전달한다. **컴포넌트가 표시될 때 인자를 받아야 하는 경우**에는 라우터를 통해 전달 할 수 있다.
2 . @NgModue 어노테이션의 import 프로퍼티에 forRoot()나 forChild()의 반환값을 추가한다.
3 . \<router-outlet> 태그를 사용해서 컴포넌트가 렌더링 될 위치를 지정한다.
4 . \[routerLink] 프로퍼티를 사용하는 HTML 앵커 태그를 추가한다.(대괄호는 프로퍼티 바인딩을 의미한다.) 그러면 사용자가 이 **링크를 클릭했을 때 해당 주소와 연결된 컴포넌트를 렌더링**한다. 결국 **\[routerLink] 프로퍼티는 앵커 태그의 href 어트리뷰트를 대체**하는 용도로 사용한다.

\[routerLink]를 사용하는 대신 **라우터의 navigate() 함수를 사용**할 수도 있다. 두 경우 모두 이동하려는 주소에 해당하는 컴포넌트의 인스턴스를 찾고, 인스턴스가 없으면 새로 생성한 후에, URL을 변경하고 컴포넌트를 렌더링한다.

