#  서비스 사용의 목적
컴포넌트는 데이터를 **직접** 가져오거나 **직접** 저장하도록 요청하지 않는 것이 좋다.
그리고 사용하는 데이터가 **실제** 데이터인지 **가짜** 데이터인지 알 필요도 없다.
컴포넌트는 데이터를 표시하는 것에만 집중하는 것이 좋다.
데이터를 처리하는 로직은 서비스에게 맡겨두는 것이 좋다.
즉 관심사의 분리(AOP)

# @Injectable() 서비스
Angular CLI로 만든 서비스 클래스에는 Injectable 심볼이 로드되어 @Injectable() 데코레이터로 사용되었다. 
이 구문은 이 클래스가 의존성 주입 시스템 에 포함되는 클래스라고 선언하는 구문이다. 
그래서 HeroService 클래스는 **의존성으로 주입될 수 있으며 이 클래스도 의존성을 주입받을 수 있다.** 

@Injectable() 데코레이터는 서비스를 정의하는 **메타데이터 객체**를 인자로 받는다. 
@Component() 데코레이터에 메타데이터를 사용했던 것과 같은 방식이다.

# HeroService 등록하기
의존성을 주입하려면 Provider를 등록해야 한다.
그래서 방금 전에 만들었던 HeroService 클래스에 사용된 @Injectable() 구문을 살펴보면 providedIn 메타데이터의 값이 root로 지정된 것을 확인할 수 있다.
```js
Injectable({
  providedIn: 'root',
})
```
**서비스가 최상위 인젝터에 등록되면** Angular는 HeroService의 인스턴스를 하나만 생성하며, 이 클래스가 주입되는 모든 곳에서 같은 인스턴스를 공유한다.
### (중요)그리고 @Injectable() 데코레이터는 이 데코레이터가 등록된 클래스가 실제로 사용되지 않으면 이 클래스를 최종 빌드 결과물에서 제거하는 대상으로 등록하는 역할도 합니다.


```js
import { Component, OnInit } from '@angular/core';
import { Hero } from '../hero';
import { HEROES } from "../mock-heroes";
import { HeroService } from "../hero.service";
@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html',
  styleUrls: ['./heroes.component.css']
})
export class HeroesComponent implements OnInit {
// 컴포넌트에서 데이터를 가져와 처리할 일을 서비스로 보내야돼!
  heroes = HEROES;
// 배열형식으로 받아온다 (getHeroes 메서드 이용)
  heroes : Hero[];

  selectedHero: Hero;
// 이렇게 작성하면 heroService 인자를 클래스 프로퍼티로 선언하면서 HeroService 타입의 의존성 객체가 주입되기를 요청한다는 것을 의미한다.
// 그러면 Angular가 HeroesComponent를 생성할 때 의존성 주입 시스템이 HeroService의 인스턴스를 찾아서 heroService 라는 인자로 전달할 것이다.
  constructor(private heroService: HeroService) { }

  ngOnInit() {
  }

  onSelect(hero: Hero)  {
    this.selectedHero = hero;
  }
}
```

# ngOnInit에서 서비스 호출하기
서비스에 구현한 getHeroes() 함수는 **컴포넌트 클래스에서도 호출할 수 있지만**, 이 방법은 최선이 아니다.
컴포넌트의 생성자는 **생성자로 받은 인자를 클래스 프로퍼티로 연결하는 정도로 간단하게 유지**하는 것이 좋다. 
생성자에는 **이 외의 로직이 들어가지 않는 것이 좋다.** 
리모트 서버로 HTTP 요청을 보내는 로직도 물론 들어가지 않는 것이 좋습니다.