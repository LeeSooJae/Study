# 컴파일(Compile)

컴파일이란 개발자가 작성한 소스코드를 **바이너리 코드로 변환**하는 과정을 말한다. (목적파일이 생성됨) 

즉, **컴퓨터가 이해할 수 있는 기계어로 변환**하는 작업이다. 이러한 작업을 해주는 프로그램을 가르켜 컴파일러(Compiler)라 한다.

자바의 경우, 자바가상머신(JVM)에서 실행가능한 바이트코드 형태의 클래스파일이 생성이 된다.


# 링크(link)
프로젝트를 진행하다 보면 소스파일이 여러개가 생성이되고 A라는 소스파일에서 B라는 소스파일에 존재하는 함수(메서드)를 호출하는 경우가 있다.

이때 A와 B 소스파일 각각을 컴파일만 하면 A가 B에 존재하는 함수를 찾질 못하기 때문에 호출할 수가 없다.

따라서 A와 B를 연결해주는 작업이 필요한데 이 작업을 링크라고 한다.

여러개로 분리된 소스파일들을 컴파일한 결과물들에서 최종 실행가능한 파일을 만들기 위해 필요한 부분을 찾아서 연결해주는 작업이다.

링크는 **정적링크(static link)**와 **동적링크(dynamic link)**가 있다.

### 정적링크 
컴파일된 소스파일을 연결해서 실행가능한 파일을 만드는 것
### 동적링크 
프로그램 실행 도중 프로그램 외부에 존재하는 코드를 찾아서 연결하는 것.

자바의 경우, JVM이 프로그램 실행 도중 필요한 클래스를 찾아서 클래스패스에 로드해주는데 이는 동적링크의 예이다.


# 빌드(Build)

소스코드 파일을 **실행가능한 소프트웨어 산출물로 만드는 일련의 과정**을 말한다. 

빌드의 단계 중 컴파일이 포함이 되어 있는데 **컴파일은 빌드의 부분집합**이라 할 수 있다.

빌드 과정을 도와주는 도구를 빌드 툴이라 한다.

## 빌드 툴(Build Tool)

일반적으로 빌드 툴이 제공해주는 기능으로는 다음과 같은 기능들이 있다.

전처리(preprocessing), 컴파일(Compile), 패키징(packaging), 테스팅(testing), 배포(distribution)

빌드 툴로는 Ant, Maven, Gradle 등이 있다.


## JPA vs MYBATIS

Jpa 장점: 쿼리를 안만들어도 된다.
Jpa 단점: 복잡한 쿼리는 해결불가 (사실 이게 퍼포먼스 향상)

mybatis 장점: 복잡한 쿼리, 다이나믹 쿼리 이점
mybatis 단점: 비슷한 쿼리 남발 .


## 스택
- Heap 영역에 생성된 Object 타입의 데이터의 참조값이 할당된다.
- 원시타입의 데이터가 값과 함께 할당된다.
- 지역변수들은 scope에 따른 visibility를 가진다.


참고 https://12bme.tistorys

# List와 Vector의 주요 차이점

1. 동기화(Synchronize)

Vector 동기화 O 
ArrayList 동기화 X

Vector는 한번에 하나의 스레드만 엑세스 O
ArrayList는 동시에 여러 스레드에 액세스 O

ArrayList에서 여러 스레드가 동시에 엑세스하는 경우 개발자가 명시적으로 동기화하는 코드를 추가해야한다.


2. 스레드 안전(Thread Safe)
멀티 스레드 프로그래밍에서 여러 스레드가 동시에 접근이 이루어져도 프로그램 실행에 문제 X
앞서 말했듯이 Vector는 동기화 되어있기 때문에 한번에 하나의 스레드만 접근할 수 있기때문에 스레드가 안전.

ArrayList는 동기화되지 않았기 때문에 명시적으로 동기화 할 필요가 있다.

3. 성능

ArrayList는 동기화 되지않았기 때문에 동기화 된 벡터보다 더 빠르다.

4. 크기 증가

Vector와 ArrayList 모두 동적 배열 클래스로 최대 인덱스를 초과할 때 추가되는 인덱스 수가 다르다.
Vector는 현재 배열의 크기의 100%가 증가하며, ArrayList의 경우 현재 배열의 크기의 50%가 증가한다.

멀티스레드 환경이 아닌 경우 ArrayList를 사용하는것이 바람직하다.

Vector를 사용하기 위한 명시적 요구 사항이 없는경우 ArrayList를 사용하자

# SOLID
## SRP (단일 책임 원칙, Single Reponsibility Principle)
작성된 클래스는 하나의 기능만 가지며, 클래스가 제공하는 모든서비스는 그 하나의 책임을 수행하는데 집중되어야 한다는 원칙.
SRP원리를 적용하면, 무엇보다도 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임 변경으로의 연쇄작용에서 자유로워짐.
객체지향 원리의 대전제 격인 OCP원리 뿐만 아니라 다른 원리들을 적용하는 기초가 된다.ㄴ

적용: 여러 원인에 의한 변경(Divergent change) : Extract Class를 통해 혼재된 각 책임을 각각의 개별 클래스로 분할하여 클래스 당 하나의 책임만을 맡도록 한다.
여기서 관건은 책임만 분리하는 것이 아니라 