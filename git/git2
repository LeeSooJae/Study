branch의 원리

gistory의 HEAD을 보면 ref가 있다
f1.txt파일을 생성하고 add하면
refs\heads\master라는 파일이 생긴다.
방금 내가 commit한 아이디가 뜬다.
초기화하면 .git/HEAD가 생성되는데 텍스트 파일이다.
refs/heads/master는 커밋을 처음 한 시점부터 생성된다.
f2.txt가 생성하면
refs/heads/master는 f2.txt를 가리킨다.

git log 를 했을때 2가 최신이라고 알려줄수 있었던 이유는 HEAD덕분이다.
깃은 HEAD라는 파일을 가리키고 있고
HEAD는 refs/heads/master라는 파일을 가리키고 있고,
이 파일은 최근의 커밋한 오브젝트 id를 가지고 있기때문에
git log를 하면 헤드파일을 보고 헤드파일에 있는 마스터파일을 보고 
마스터 파일에 적혀있는 커밋 오브젝트 id값을 통해서 현재 commit된 가장 최신 commit이 무엇인가를 
알아낼 수 있다. 그리고 그 이전 commit은 parent라는 것을 통해서 탐색해 나갈 수 있다.
이것을 통해서 알수 있는 것은 git에서 branch라고 하는 것은 단지 refs라는 디렉토리 안에 있는 파일을 의미한다.

$ rm .git/refs/heads/exp
로 exp를 삭제 했을때 git branch를 보면 exp는 사라져있다.

$ vim .git/refs/heads/exp를 한 후에
최신 커밋의 ID값 6fff3fda34fe3ccaa04d266b626fa3a6378f3b57 를 추가해주면
다시 exp라는 branch가 생성된다.
git에서 branch라는 것은 중요하고 강력하지만, g단지 파일 하나일 뿐이다.
 심지어 binary도 아니고 일반 텍스트 파일이다.

$ git checkout exp를 하면
HEAD는 exp를 가리킨다.

현재 사용하고있는 branch 무엇인가를 가리키는 약속된 기호가 head인데 head는 어떤 특정한 파일이다.
HEAD가 하는 역할은 현재 checkout된 가장 최신 commit이 무엇인가를 나타내준다..

master branch와 exp branch의 같은 이름의 파일을 만들어보자
exp branch로 가서 common.txt파일을 만든 후, master branch로 와서
exp branch와 병합을 해준다. 그 이후에 master branch에서 common.txt파일을 수정한다.
다시 exp로 가서 common.txt파일을 수정한다.
즉, common.txt인 파일을 서로 다르게 수정했다.

$ git merge exp
를 하면 내용의 위치가 다를경우, master에서 작성된 내용과 exp에서 작성한 내용이 합쳐진다.
(common.txt 내용이 b이고 , master에서 a b이고, exp 에서 b c이면 a b c 가 출력된다.)
BUT!!! 같은 부분을 수정하면(master에서 a를 a(master)라고 하고 exp에서는 a(exp)라고 할때)

$ git merge exp
Auto-merging common.txt
CONFLICT (content): Merge conflict in common.txt
Automatic merge failed; fix conflicts and then commit the result.

$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)

        both modified:   common.txt

no changes added to commit (use "git add" and/or "git commit -a")


충돌이 일어난다.
$ vim common.txt

function b(){
}
<<<<<<< HEAD   //HEAD부분이 checkout한 branch의 수정사항(즉 master)
function a(master){
=======
function a(exp){
>>>>>>> exp // exp branch의 수정사항
}
function c(){
}

git이 우리에게 merge를 실패했기 때문에 우리에게 해결하라고 표시해준것.

예를들어

function b(){
}
function a(master,exp){
}
function c(){
}

로 바꿔준다.

다 하고 commit을 해보면 충돌이 났었다고 써져있다.

$ git reset --hard c7081fa5659e1d4430c578493bb6ca2f45cc1bc1

refs/heads/master 
어떤 커밋을 최신커밋을 가지고 있나

reset을 한다는 것을 head가 가리키고있는 커밋을 바꾸는 행위(간단)
git은 왠만하면 파일을 정리하지 않는다 
reset을 한다고해서 실제로 지워진게 아니라 눈에만 안보일 뿐이다.
ORIG_HEAD를 눌러보면 우리가 지운 4번이 있다.
logs/refs/heads/master 파일을 보면 제일 끝에 행에 f3ea~ 가 93c~가 되었다고 나온다.
최신 커밋인 3으로 교체했다는 뜻이다.
현재 branch의 헤드가 가리키고 있는 COMMIt을 ORIG_HEAD에 기록한 후에 RESET을 실행한다.

$ git reset --hard ORIG_HEAD
하면 RESET을 취소할수 있다.

$ git reflog
95a7277 (HEAD -> master) HEAD@{0}: reset: moving to ORIG_HEAD
c7081fa HEAD@{1}: reset: moving to c7081fa5659e1d4430c578493bb6ca2f45cc1bc1
95a7277 (HEAD -> master) HEAD@{2}: commit: 4
c7081fa HEAD@{3}: commit: 3
38e292c HEAD@{4}: commit: 2
15e18dd HEAD@{5}: commit (initial): 1

각각의 commit이 담겨있다.
git reset 95a7277이라고 쓰면 복구된다.
또한 취소할때 reset HEAD@{0}이라고 해도된다.

git 로그에 있는 c7081fa5659e1d4430c578493bb6ca2f45cc1bc1
을 git checkout c7081fa5659e1d4430c578493bb6ca2f45cc1bc1 라고 하면

source tree ddd