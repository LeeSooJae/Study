선택정렬 : 가장 작은 값을 앞으로 보낸다.
버블정렬 : 인접한 수와 비교후 바꾼다.
삽입정렬 : 왼쪽인덱스와 한칸씩만 비교 (왼쪽은 다 정렬되어있는 상태이므로) 
          왼쪽값이 더 크면 한칸 옆으로 이동한다. (tmp 필요)

특정 인덱스 i에 대한 왼쪽 자식 노드의 i \* 2+1 에 해당되며 오른쪽 자식 노드는 i \* 2+2에 해당된다.
최대힙 성질을 만족하도록 트리를 조정해야한다.
실제로는 가장 말단에 있는 것부터 해야 하지만, 마지막 ㄷ노드는 리프노드로 자식이 존재하지 않는다.
5/2=2인 2번 인덱스 부터 시작한다.
https://lktprogrammer.tistory.com/70

Max-HEAPIFY는 자식을 가지는 마지막 노드부터 시작한다. (length/2) 


Inorder
1. Left
2. Root
3. Right

Preorder
1. Root
2. Left
3. Right

Postorder
1. Left
2. Right
3. Root



## 그래프
방향이 있는 그래프 : Directed grapgh(트리)
방향이 없는 그래프
Cyclic 그래프, Acyclic 그래프        

그래프를 표현하는 방법
- Adjacency Matrix //표에 표현
- Adjacency List  // 배열에 표현


해시함수 : 특정한 규칙을 이용해 키값을 받아 해시코드로 전송한다.

해시코드는 정수다. 배열 공간을 미리 만들어서 해시코드를 배열로 나누어서 담는다.
해시코드 자체가 배열의 인덱스로 사용되어서 인덱스를 구할 필요없이 다이렉트로 접근한다.

그러나 해시함수를 이용하여 1,2,3번방에 10개의 값을 넣고자할때 1번방에만 10개를 넣고 2,3번방은 텅텅 비면 안되니까 이때 해시알고리즘을 사용한다. (collision 방지)

O(1)~ O(n)

키(SooJae) -> 해시함수 -> 해시코드(3333) -> 인덱스 -> 저장

해시함수 알고리즘은 얼마나 잘 골고루 담느냐에 따라 성능을 평가 받는다.

다른 키 값으로 동일한 해시코드를 만든다. (키값은 문자열이고, 해시코드는 정수인데 정수가 제한되어있기때문에 )
해시함수가 서로 다른 해시코드를 만들었는데, 배열방이 한정되어있어서 같은 인덱스가 생성될 수 있다.


해시코드 예시
1. 키를 입력받는다.
2. 각 문자의 아스키코드를 더한다. s(115)+j(106) = 221, m(109)+n(110) = 219
3. 고정된 배열방을 만든다 (3)
4. 221% 3 = 2에 저장 219%3 = 0
5. 그 후에 배열에 LinkedList를 만들어서 할당 될때마다 노드를 하나씩 붙여준다.